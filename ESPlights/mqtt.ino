//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

void mqtt_setup()
{
    client.begin(MQTT_HOST, MQTT_PORT, net);
    client.setWill(MQTT_WILL_TOPIC, "0", true, 0);
    client.onMessage(messageReceived);
    mqtt_connect();
}

//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

void mqtt_connect()
{
    uint8_t i = 0;
    bool pin_states = false;

    while (WiFi.status() != WL_CONNECTED)
    {
        delay(100);
        i++;
        if (i > 200)
            ESP.restart();
    }

    // certificare
    BearSSL::X509List cert(digicert);
    net.setTrustAnchors(&cert);

    while (!client.connect(HOSTNAME, MQTT_USER, MQTT_PASS))
    {
        delay(100);
        i++;
        if (i > 200)
            ESP.restart();
    }

    client.subscribe(MQTT_SAVE_TOPIC, 0);
    client.publish(MQTT_WILL_TOPIC, "1", true, 0);
}

//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

void messageReceived(String &topic, String &payload)
{
    if (topic == MQTT_SAVE_TOPIC)
    {
        client.unsubscribe(MQTT_SAVE_TOPIC);
        client.subscribe(MQTT_CMND_TOPIC, 0);
        if (!pin_states)
        {
            pin_states = true;
            pins = payload.toInt();
            update_MCP();
            return;
        }
    }

    StaticJsonDocument<256> doc;
    deserializeJson(doc, payload);
    yield();

    uint8_t pin = doc["channel"];
    uint8_t value = doc["state"];

    doc.clear();

    update_pins(pin, value);
}

//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

void init_mac_topics()
{
    sprintf(HOSTNAME, "%s_%x", TIP, ESP.getChipId());
    sprintf(MQTT_WILL_TOPIC, "%s%x%s", PREFIX, ESP.getChipId(), WILL);
    sprintf(MQTT_CHAN_TOPIC, "%s%x%s", PREFIX, ESP.getChipId(), CHAN);
    sprintf(MQTT_CMND_TOPIC, "%s%x%s", PREFIX, ESP.getChipId(), CMND);
    sprintf(MQTT_STAT_TOPIC, "%s%x%s", PREFIX, ESP.getChipId(), STAT);
    sprintf(MQTT_SAVE_TOPIC, "%s%x%s", PREFIX, ESP.getChipId(), SAVE);
}

//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

void send_heartbeat()
{
    char tx[256];
    float supply = (float)ESP.getVcc() / FACTOR;

    sprintf(tx, "{\"Type\":\"%s\",\"ID\":\"%x\",\"Vin\":%.2f,\"SSID\":\"%s\",\"RSSI\":%d,\"BSSID\":\"%s\"}", TIP, ESP.getChipId(), supply, WiFi.SSID().c_str(), WiFi.RSSI(), WiFi.BSSIDstr().c_str());

    client.publish(MQTT_STAT_TOPIC, tx, false, 0);
}

//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
